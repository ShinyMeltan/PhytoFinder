<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PhytoFinder</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');

  body {
    font-family: 'Inter', Arial, sans-serif;
    max-width: 600px;
    margin: 50px auto;
    background-color: #f9faf9;
    color: #2f3e46;
    padding: 0 20px 40px;
  }

  h1 {
    text-align: center;
    font-weight: 300;
    letter-spacing: 1.2px;
    margin-bottom: 0.3em;
    color: #1b4332;
  }

  h2 {
    font-weight: 300;
    letter-spacing: 0.8px;
    color: #344e41;
    margin-bottom: 15px;
  }

  .plants, .results {
    margin-top: 30px;
  }

  label {
    display: block;
    margin: 8px 0;
    cursor: pointer;
    color: #344e41;
  }

  #search-container {
    position: relative;
  }

  #plant-search {
    width: 100%;
    padding: 12px 16px;
    font-size: 1rem;
    box-sizing: border-box;
    border: 1.8px solid #a7c4a0;
    border-radius: 10px;
    outline-offset: 2px;
    outline-color: #6a994e;
    background-color: #f0f5f1;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 1px 4px rgba(106, 153, 78, 0.15);
  }
  #plant-search:focus {
    border-color: #52734d;
    box-shadow: 0 0 8px rgba(82, 115, 77, 0.5);
    background-color: #e6f0e8;
  }

  #suggestions {
    position: absolute;
    top: 110%;
    left: 0;
    right: 0;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    max-height: 180px;
    overflow-y: auto;
    z-index: 1000;
    padding: 8px 0;
  }
  #suggestions div {
    padding: 10px 20px;
    cursor: pointer;
    color: #344e41;
    font-weight: 500;
    transition: background-color 0.25s ease, color 0.25s ease;
  }
  #suggestions div:hover {
    background-color: #d1e7c2;
    color: #1b4332;
  }

  #selected-plants {
    margin-top: 15px;
  }
  #selected-plants span {
    display: inline-flex;
    align-items: center;
    background-color: #a7c4a0;
    border-radius: 9999px;
    padding: 6px 14px;
    margin: 5px 8px 5px 0;
    font-weight: 600;
    color: #1b4332;
    box-shadow: 0 2px 6px rgba(106, 153, 78, 0.3);
    user-select: none;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
  }
  #selected-plants span:hover {
    background-color: #8aa46a;
    box-shadow: 0 4px 12px rgba(106, 153, 78, 0.5);
  }
  #selected-plants span .remove-plant {
    margin-left: 10px;
    color: #3a0e0e;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    transition: color 0.3s ease;
  }
  #selected-plants span .remove-plant:hover {
    color: #7f1d1d;
  }

  button {
    margin-top: 25px;
    padding: 12px 25px;
    font-size: 1.1rem;
    font-weight: 600;
    color: #f0f5f1;
    background-color: #52734d;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 6px 12px rgba(82, 115, 77, 0.4);
    transition: background-color 0.3s ease, box-shadow 0.3s ease, transform 0.15s ease;
  }
  button:hover {
    background-color: #3e5c34;
    box-shadow: 0 8px 20px rgba(62, 92, 52, 0.6);
    transform: translateY(-2px);
  }
  button:active {
    transform: translateY(0);
    box-shadow: 0 4px 10px rgba(62, 92, 52, 0.5);
  }

  .results {
    font-weight: 500;
    color: #344e41;
    margin-top: 35px;
  }
  .results h3 {
    font-weight: 400;
    color: #52734d;
    margin-bottom: 12px;
    letter-spacing: 0.5px;
  }
  .results ul {
    padding-left: 20px;
    color: #344e41;
  }
  .results li {
    margin-bottom: 6px;
  }
</style>
</head>
<body>

<h1>PhytoFinder</h1>

<div class="plants">
  <h2>Select Plants</h2>
  <div id="search-container">
    <input type="text" id="plant-search" placeholder="Search plants..." autocomplete="off" />
    <div id="suggestions" style="display:none;"></div>
  </div>
  <div id="selected-plants"></div>
  <button id="find-common">Find Common Chemicals</button>
</div>

<div class="results" id="results"></div>

<script>
  // chemicalList defines the master list of chemicals, in a specific order.
  // Each index in this array corresponds to a column in the plantMatrix.
  const chemicalList = [
    "Linalool", "Eugenol", "Camphor", "Thymol",
    "Menthol", "Citral", "Myrcene", "Geraniol",
    "Pinene", "Carvacrol"
  ];

  // plantMatrix maps each plant to an array of 0s and 1s, where each position
  // corresponds to the presence (1) or absence (0) of the chemical at that index
  // in chemicalList. This acts as a binary "fingerprint" for each plant.
  // This original matrix uses scientific names as keys.
  const plantMatrix = {
    Basil:    [1,1,0,0,0,0,0,0,0,0],
    Lavender: [1,0,1,0,0,0,0,0,0,0],
    Thyme:    [0,0,0,1,0,0,0,0,0,0],
    Mint:     [1,0,0,0,1,0,0,0,0,0],
    Oregano:  [1,0,0,0,0,0,0,0,0,1],
    Rosemary: [0,1,0,0,0,0,0,0,1,0],
    Sage:     [1,0,0,0,0,0,1,0,0,0]
  };

  // Variables for loaded data and mappings
  let fnfData = {}; // fnfnum -> { scientific: string, taxon: string, commons: [] }
  let nameToFnf = new Map(); // name (common, scientific, or taxon) lowercased -> fnfnum
  let searchableNames = []; // array of { name, fnfnum }
  let plants = []; // will be replaced by searchableNames.map(n => n.name)

  // New mapping for fnfnum to Set of chemicals
  let fnfChemicals = {}; // fnfnum -> Set of chemical names

  const plantSearchInput = document.getElementById("plant-search");
  const suggestionsDiv = document.getElementById("suggestions");
  const selectedPlantsDiv = document.getElementById("selected-plants");

  // Selected plants by fnfnum
  const selectedPlants = [];

  // Load and parse CSVs, then build mappings
  async function loadPlantData() {
    console.log("Loading plant data...");
    // Fetch scientific names CSV
    let sciText = "";
    try {
      const sciResp = await fetch('data/scientific_names.csv');
      if (!sciResp.ok) throw new Error(`HTTP error! Status: ${sciResp.status}`);
      sciText = await sciResp.text();
    } catch (err) {
      console.error("Failed to fetch scientific_names.csv:", err);
    }

    // Fetch common names CSV
    let comText = "";
    try {
      const comResp = await fetch('data/common_names.csv');
      if (!comResp.ok) throw new Error(`HTTP error! Status: ${comResp.status}`);
      comText = await comResp.text();
    } catch (err) {
      console.error("Failed to fetch common_names.csv:", err);
    }
    console.log("Common names parsed:", fnfData);
    console.log("searchableNames:", searchableNames.map(n => n.name));
    // Parse scientific_names.csv
    // Expected format: fnfnum,scientific_name,...,TAXON (4th column)
    sciText.trim().split('\n').forEach(line => {
      const cols = line.split(',').map(s => s.trim());
      const fnfnum = cols[0];
      const scientific = cols[1];
      const taxon = cols[3] || ""; // 4th column is TAXON
      if (fnfnum && scientific) {
        fnfData[fnfnum] = { scientific: scientific, taxon: taxon, commons: [] };
      }
    });

    // Parse common_names.csv
    // Expected format: fnfnum,common_name
    comText.trim().split('\n').forEach(line => {
      const [fnfnum, common] = line.split(',').map(s => s.trim());
      if (fnfnum && common && fnfData[fnfnum]) {
        fnfData[fnfnum].commons.push(common);
        searchableNames.push({ name: common, fnfnum });
        nameToFnf.set(common.toLowerCase(), fnfnum);
      }
    });

    // Load and parse phytochemicals1.csv
    let phyto1Text = "";
    try {
      const phyto1Resp = await fetch('data/phytochemicals1.csv');
      if (!phyto1Resp.ok) throw new Error(`HTTP error! Status: ${phyto1Resp.status}`);
      phyto1Text = await phyto1Resp.text();
    } catch (err) {
      console.error("Failed to fetch phytochemicals1.csv:", err);
    }
    phyto1Text.trim().split('\n').forEach(line => {
      const cols = line.split(',').map(s => s.trim());
      const fnfnum = cols[0];
      const chemical = cols.length > 2 ? cols.slice(1, cols.length - 1).join(',').trim() : cols[1];
      // Skip PPCO for now (last column)
      if (fnfnum && chemical) {
        if (!fnfChemicals[fnfnum]) {
          fnfChemicals[fnfnum] = new Set();
        }
        fnfChemicals[fnfnum].add(chemical);
      }
    });

    // Load and parse phytochemicals2.csv
    let phyto2Text = "";
    try {
      const phyto2Resp = await fetch('data/phytochemicals2.csv');
      if (!phyto2Resp.ok) throw new Error(`HTTP error! Status: ${phyto2Resp.status}`);
      phyto2Text = await phyto2Resp.text();
    } catch (err) {
      console.error("Failed to fetch phytochemicals2.csv:", err);
    }
    phyto2Text.trim().split('\n').forEach(line => {
      const cols = line.split(',').map(s => s.trim());
      const fnfnum = cols[0];
      const chemical = cols.length > 2 ? cols.slice(1, cols.length - 1).join(',').trim() : cols[1];
      // Skip PPCO for now (last column)
      if (fnfnum && chemical) {
        if (!fnfChemicals[fnfnum]) {
          fnfChemicals[fnfnum] = new Set();
        }
        fnfChemicals[fnfnum].add(chemical);
      }
    });

    // Build searchableNames array and nameToFnf map
    searchableNames = [];
    nameToFnf.clear();
    for (const fnfnum in fnfData) {
      const entry = fnfData[fnfnum];
      // Add common names
      entry.commons.forEach(commonName => {
        searchableNames.push({ name: commonName, fnfnum });
        nameToFnf.set(commonName.toLowerCase(), fnfnum);
      });
      // Add taxon name for searching and display
      if (entry.taxon) {
        searchableNames.push({ name: entry.taxon, fnfnum });
        nameToFnf.set(entry.taxon.toLowerCase(), fnfnum);
      }
      // Removed adding scientific names to searchableNames and nameToFnf
      // searchableNames.push({ name: entry.scientific, fnfnum });
      // nameToFnf.set(entry.scientific.toLowerCase(), fnfnum);
    }

    // Sort searchableNames alphabetically by name for better UX
    searchableNames.sort((a,b) => a.name.localeCompare(b.name));

    // Replace plants array with all names
    plants = searchableNames.map(n => n.name);
  }

  // Helper to get display name for a fnfnum: prefer taxon, else first common, else scientific
  function getDisplayName(fnfnum) {
    const entry = fnfData[fnfnum];
    if (!entry) return fnfnum;
    if (entry.taxon) return entry.taxon;
    if (entry.commons.length > 0) return entry.commons[0];
    return entry.scientific;
  }

  // Render selected plants by their display names
  function renderSelectedPlants() {
    selectedPlantsDiv.innerHTML = "";
    selectedPlants.forEach(fnfnum => {
      const span = document.createElement("span");
      span.textContent = getDisplayName(fnfnum);
      const removeBtn = document.createElement("span");
      removeBtn.textContent = "×";
      removeBtn.className = "remove-plant";
      removeBtn.title = "Remove";
      removeBtn.addEventListener("click", () => {
        const index = selectedPlants.indexOf(fnfnum);
        if (index > -1) {
          selectedPlants.splice(index, 1);
          renderSelectedPlants();
        }
      });
      span.appendChild(removeBtn);
      selectedPlantsDiv.appendChild(span);
    });
  }

  // currentMatches holds filtered suggestions as objects {name, fnfnum}
  let currentMatches = [];

  plantSearchInput.addEventListener("input", () => {
    const query = plantSearchInput.value.trim().toLowerCase();
    if (!query) {
      suggestionsDiv.style.display = "none";
      suggestionsDiv.innerHTML = "";
      currentMatches = [];
      return;
    }

    // Filter searchableNames by input query, excluding those whose fnfnum is already selected.
    currentMatches = searchableNames.filter(({name, fnfnum}) => 
      name.toLowerCase().startsWith(query) && !selectedPlants.includes(fnfnum)
    ).slice(0, 5);

    if (currentMatches.length === 0) {
      suggestionsDiv.style.display = "none";
      suggestionsDiv.innerHTML = "";
      return;
    }

    // Render suggestions as clickable divs with display names (use taxon if available)
    suggestionsDiv.innerHTML = currentMatches.map(({name}) => `<div>${name}</div>`).join("");
    suggestionsDiv.style.display = "block";
  });

  // Allow selecting the first suggestion by pressing Enter.
  plantSearchInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && currentMatches && currentMatches.length > 0) {
      const selectedFnfnum = currentMatches[0].fnfnum;
      if (!selectedPlants.includes(selectedFnfnum)) {
        selectedPlants.push(selectedFnfnum);
        renderSelectedPlants();
      }
      // Clear search and hide suggestions
      plantSearchInput.value = "";
      suggestionsDiv.style.display = "none";
      suggestionsDiv.innerHTML = "";
      plantSearchInput.focus();
      // Prevent form submission or default Enter behavior
      e.preventDefault();
    }
  });

  // Handle clicking a suggestion to select a plant.
  suggestionsDiv.addEventListener("click", (e) => {
    if (e.target && e.target.nodeName === "DIV") {
      const clickedName = e.target.textContent;
      const fnfnum = nameToFnf.get(clickedName.toLowerCase());
      if (fnfnum && !selectedPlants.includes(fnfnum)) {
        selectedPlants.push(fnfnum);
        renderSelectedPlants();
      }
      // Clear search and hide suggestions
      plantSearchInput.value = "";
      suggestionsDiv.style.display = "none";
      suggestionsDiv.innerHTML = "";
      plantSearchInput.focus();
    }
  });

  // Hide suggestions if clicking outside the search container.
  document.addEventListener("click", (e) => {
    if (!document.getElementById("search-container").contains(e.target)) {
      suggestionsDiv.style.display = "none";
      suggestionsDiv.innerHTML = "";
    }
  });

  /**
   * Finds chemicals present in a majority (>50%) of selected plants.
   * Returns array of objects: { name, percentSelected, percentAll, score }
   * @param {string[]} selectedFnfnums - Array of selected plant fnfnum keys.
   * @returns {{ name: string, percentSelected: number, percentAll: number, score: number }[]} Array of chemical objects.
   */
  function findRelevantChemicals(selectedFnfnums) {
    if (!selectedFnfnums || selectedFnfnums.length === 0) return [];
    const chemCount = {};
    // Count occurrences in selected plants
    selectedFnfnums.forEach(fnfnum => {
      const chems = fnfChemicals[fnfnum];
      if (chems) {
        chems.forEach(chem => {
          chemCount[chem] = (chemCount[chem] || 0) + 1;
        });
      }
    });
    // Count occurrences in all plants
    const allFnfnums = Object.keys(fnfChemicals);
    const chemCountAll = {};
    allFnfnums.forEach(fnfnum => {
      const chems = fnfChemicals[fnfnum];
      if (chems) {
        chems.forEach(chem => {
          chemCountAll[chem] = (chemCountAll[chem] || 0) + 1;
        });
      }
    });
    const totalSelected = selectedFnfnums.length;
    const totalAll = allFnfnums.length;
    const res = [];
    for (const chem in chemCount) {
      const percentSelected = Math.ceil((chemCount[chem] / totalSelected) * 100);
      if (percentSelected > 50) {
        const countAll = chemCountAll[chem] || 0;
        const percentAll = totalAll === 0 ? 0 : Math.ceil((countAll / totalAll) * 100);
        // Score: percentSelected / percentAll (floating point, rounded to 2 decimals)
        let score = percentAll === 0 ? 0 : (chemCount[chem] / totalSelected) / (countAll / totalAll);
        score = Math.round(score * 100) / 100;
        res.push({
          name: chem,
          percentSelected,
          percentAll,
          score
        });
      }
    }
    // Sort by score descending, then by percentSelected descending, then by name
    res.sort((a, b) =>
      b.score - a.score ||
      b.percentSelected - a.percentSelected ||
      a.name.localeCompare(b.name)
    );
    return res;
  }

  // When the user clicks the "Find Common Chemicals" button,
  // calculate and display chemicals present in a majority of selected plants.
  document.getElementById("find-common").addEventListener("click", () => {
    const resultsDiv = document.getElementById("results");
    const relevantChemicals = findRelevantChemicals(selectedPlants);
    if (relevantChemicals.length === 0) {
      resultsDiv.textContent = "No common chemicals found among the selected plants.";
    } else {
      // Render as text-based table with 4 columns: Chemical Name | % of Plants | % of All Plants | Score
      let table = `<h3>Common Chemicals (Majority):</h3>\n<pre>\n`;
      // Column widths: name (17), % of Plants (13), % of All Plants (16), Score (7)
      table += `Chemical Name     | % of Plants | % of All Plants | Score \n`;
      table += `----------------- | ------------| ----------------| ------\n`;
      relevantChemicals.forEach(({ name, percentSelected, percentAll, score }) => {
        // Pad columns for alignment
        const namePadded = name.padEnd(17, " ");
        const percentSelPadded = (percentSelected + "%").padEnd(12, " ");
        const percentAllPadded = (percentAll + "%").padEnd(16, " ");
        const scorePadded = score.toFixed(2).padEnd(6, " ");
        table += `${namePadded}| ${percentSelPadded}| ${percentAllPadded}| ${scorePadded}\n`;
      });
      table += `</pre>`;
      resultsDiv.innerHTML = table;
    }
  });

  // Initialize by loading plant data
  loadPlantData();

</script>

</body>
</html>